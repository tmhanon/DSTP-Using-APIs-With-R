[
  {
    "objectID": "index.html#my-background",
    "href": "index.html#my-background",
    "title": "Working with APIs in R",
    "section": "My Background",
    "text": "My Background\n\nAgricultural Economist in AMS Dairy Program\nStarted with AMS in 2022\nPh.D. in Agricultural and Resource Economics from UC Davis\n\nStarted working in R in grad school because I did not want to rely on proprietary software anymore (in other words, I was cheap and broke).\nI have not always been good about using APIs, so I started trying to prioritize them in my work at USDA.\n\nI am an agricultural economist with the AMS Dairy Program. I provide analysis to support the Federal Milk Marketing Orders, work with Commodity Procurement to support their purchases of dairy products, and contribute to the WASDE projections for dairy.\nI started with AMS in 2022, but previously had a stint with NASS when I was in undergrad. I also worked for the Congressional Budget Office between undergrad and grad school, so I am no stranger to government work.\nI received my masters and Ph.D. from UC Davis."
  },
  {
    "objectID": "index.html#assumptions",
    "href": "index.html#assumptions",
    "title": "Working with APIs in R",
    "section": "Assumptions",
    "text": "Assumptions\n\nTo make this seminar as accessible as possible, I tried to make a limited set of assumptions about what knowledge you all have coming into this. However, I do want to start by assuming some knowledge at least.\nFirst, I think it is safe to assume some familiarity with the tidyverse since it is used extensively in the coursework so far. In general, I will not be explaining tidyverse functions, though I will try to provide links to their documentation in the slides.\nI will also be using the pipe extensively. I still tend to use the tidyverse pipe more often than the base pipe, but I will use both at different points in the presentation.\nI am going to discuss functions in depth (and even get into building some functions later on), so I am assuming you will know what I mean when I talk about a functions arguments and other aspects of functions.\nFinally, this may sound a bit silly, but I need to assume some understanding of how the internet works. APIs are inherently part of the web architecture, so working with APIs involves a lot of concepts associated with the internet. This is still going to be fairly basic though, like the idea that when you access a website there is communication between a client (your computer) and a server.\n\nI am making a (limited) set of assumptions about your knowledge coming into this seminar:\n\nFamiliarity with tidyverse functions and the pipe (both %&gt;% and |&gt;)\nFamiliarity with R object and data types (e.g., string, list, vector)\nUnderstanding of function terminology (e.g., what an argument is)\nSome understanding of how the internet works\n\n\nWhenever I use functions from packages outside of the tidyverse, I will specify them using the package_name::function_name() syntax to make it clear where they come from.\n\n\nTherefore, I’m only going to load one package to use in this presentation:\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "index.html#topics-covered",
    "href": "index.html#topics-covered",
    "title": "Working with APIs in R",
    "section": "Topics Covered",
    "text": "Topics Covered\n\nDefinitions: What even is an API?\nExample API: Mandatory Price Reporting Data\nHow to interact with APIs using R and the httr2 package\nBuilding an API Function\nAPI Authentication\nExample API: My Market News"
  },
  {
    "objectID": "index.html#what-is-an-api",
    "href": "index.html#what-is-an-api",
    "title": "Working with APIs in R",
    "section": "What is an API?",
    "text": "What is an API?\n\nThe term API can also be used to refer to any means of interacting with a piece of software. For example, the way a specific R package interacts with R could be describes as the package’s API (one piece of software communicating with another).\nIn data science, we typically mean web API when we say API. A server-side web API will have a set of defined endpoints\n\nAPI stands for Application Programming Interface.\n\nAs a general term, it is a framework which connects computers or software together.\n\n\nIn a data science context, typically refers to a system allowing access to data via a specialized request-response framework.\n\n\nA more precise definition would be to refer to the latter as web APIs, but they are often simply called APIs."
  },
  {
    "objectID": "index.html#web-apis",
    "href": "index.html#web-apis",
    "title": "Working with APIs in R",
    "section": "Web APIs",
    "text": "Web APIs\n\nThe most common architecture or design for web APIs is called REST, which stands for Representational State Transfer. An API which conforms to the REST guidelines is often referred to as RESTful. I’m going to describe this style of API since it is what I am familiar with (and likely what you will run into in the wild), but be aware there are other styles of APIs for specific use cases.\nAs an aside, HTTP (hypertext transfer protocol) is also a very general term that describes a request-response framework in a client-server model. Any time you utilize a web browser to access a website, you are sending an HTTP request to a server and receiving a response.\n\n\nA web API will have a set of defined endpoints that a user can access with a correctly-formatted request and receive a response.\n\nRequests are typically formatted using HTTP and use one of a set of verbs, the most common being GET and POST. To access data, GET is the verb to use.\n\n\nResponses can be in the form of JSON, XML, HTML, or plain text data, though JSON is the most common."
  },
  {
    "objectID": "index.html#anatomy-of-an-api-call",
    "href": "index.html#anatomy-of-an-api-call",
    "title": "Working with APIs in R",
    "section": "Anatomy of an API Call",
    "text": "Anatomy of an API Call\nLet’s look at an API call some of us have seen already (from Intermediate Assignments 1 and 2):\n\nhttps://api.census.gov/data/2020/dec/pl?get=P1_001N&for=county\n\n\nThe first part is the base URL used across the Census API.\n\n\nThe next part defines the API endpoint: /2020/dec is pointing the the 2020 Decennial Census, within which /pl specifies the specific dataset. In this case, the full endpoint points to the redistricting data from the 2020 Decennial Census.\n\n\nEverything after the ? defines the query parameters:\n\n\n\nget=P1_001N says we are using a GET HTTP action and requesting the P1_001N variable (total population).\n& is used to separate query parameters if multiple are specified.\nfor=county specifies the geography level, i.e. county-level total population. This could be changed to for=state to return state-level population, or another specific named geography."
  },
  {
    "objectID": "index.html#why-use-an-api",
    "href": "index.html#why-use-an-api",
    "title": "Working with APIs in R",
    "section": "Why use an API?",
    "text": "Why use an API?\nUsing a web API requires some extra work. What is the benefit of that extra effort?\n\nRegularly updated data: If you are using high-frequency data, using an API ensures you always have access to the most up-to-date data.\nReproducibility: Know what you are getting each time the code is run. Ensure your collaborators get the same results as you.\nReusability: In many cases, once the code is written it can be used over and over (especially if you build a function).\nAutomation: Using an API can remove manual processes, such as downloading data."
  },
  {
    "objectID": "index.html#mandatory-price-reporting-data",
    "href": "index.html#mandatory-price-reporting-data",
    "title": "Working with APIs in R",
    "section": "Mandatory Price Reporting Data",
    "text": "Mandatory Price Reporting Data\n\n\nSuppose we need to access data from the Dairy Product Mandatory Reporting Program (DPMRP).\nThis program collects prices and sales volumes for butter, cheese, dry whey, and nonfat dry milk.\nThese data are accessible through the Datamart website (as are data from other mandatory reporting programs).\n\n\n\n\nAs an example, let’s look at the data collected through the Dairy Product Mandatory Reporting Program. Obviously, as someone working in Dairy Program, these are data I use regularly, but they provide a good example of public USDA data that are accessible via API.\n(Click through to the Datamart website and walk through the steps of accessing data that way)."
  },
  {
    "objectID": "index.html#datamart-api-user-guide",
    "href": "index.html#datamart-api-user-guide",
    "title": "Working with APIs in R",
    "section": "Datamart API User Guide",
    "text": "Datamart API User Guide\n\nIt is always a good idea to review any available API documentation.\nThe Datamart API user guide primarily covers accessing the API using Excel or Postman (another piece of software specifically focused on working with APIs). But it also give us a couple of example URLs that we can use to learn more about how to access data through the API.\n\nDatamart data are accessible through an API, and the main Datamart webpage has a link to a user guide for that API.\n\n\nThe following URL provides access to butter prices and sales data:\nhttps://mpr.datamart.ams.usda.gov/services/v1.1/reports/2993/Butter%20Prices%20and%20Sales\n\n\nBut how do we access these data from within R?"
  },
  {
    "objectID": "index.html#httr2",
    "href": "index.html#httr2",
    "title": "Working with APIs in R",
    "section": "httr2",
    "text": "httr2\n\nhttr2, pronounced “hitter 2”, is a package developed by Hadley Wickham, the mastermind behind the tidyverse.\nAs the name suggests, it is a “sequel” to the package httr, which is also widely used for API access in R.\nHowever, httr2 has a lot of newer features that expand on the abilities of httr. These features also make it easier to build functions and packages to access APIs.\n\n\n\nhttr2 is a package developed by Hadley Wickham, the mastermind behind the tidyverse, which provides a robust framework for building and executing HTTP requests.\nFirst released in 2021 (so, relatively new in terms of R packages)."
  },
  {
    "objectID": "index.html#httr2-1",
    "href": "index.html#httr2-1",
    "title": "Working with APIs in R",
    "section": "httr2",
    "text": "httr2\n\n\nhttr2 is a package developed by Hadley Wickham, the mastermind behind the tidyverse, which provides a robust framework for building and executing HTTP requests.\nFirst released in 2021 (so, relatively new in terms of R packages).\n\n\n\nAdvantages:\n\nCreates explicit request objects instead of executing a request automatically.\nAllows piping of request and response objects.\nSecurely handles secrets/credentials for accessing APIs."
  },
  {
    "objectID": "index.html#httr2-2",
    "href": "index.html#httr2-2",
    "title": "Working with APIs in R",
    "section": "httr2",
    "text": "httr2\n\nThere are a couple downsides I see to using httr2. First, it is a bit more complex than httr and therefore has a bit more of a learning curve. However, I think taking the time to learn its features is more beneficial in the long run.\nSecond, it is still developing, and occasionally changes come along that can break existing code. This happened to me at one point, and I’ll get into exactly what happened a little later.\n\n\n\nhttr2 is a package developed by Hadley Wickham, the mastermind behind the tidyverse, which provides a robust framework for building and executing HTTP requests.\nFirst released in 2021 (so, relatively new in terms of R packages).\n\n\n\nDisadvantages:\n\nMore complex than alternative options (namely httr).\nStill in development… can occasionally break your code."
  },
  {
    "objectID": "index.html#creating-a-httr2-request",
    "href": "index.html#creating-a-httr2-request",
    "title": "Working with APIs in R",
    "section": "Creating a httr2 Request",
    "text": "Creating a httr2 Request\n\nThe first step is to create a request object.\nA httr2_request object is technically a list object containing a variety of information (most of which is actually empty in a simple case like this).\nPrinting the req object gives us a bit of information about what it contains, including the URL.\n\nA request object is created by first passing a base URL to the httr2::request() function.\n\nLet’s circle back to the URL from the Datamart API:\n\nreq &lt;- \"https://mpr.datamart.ams.usda.gov/services/v1.1/reports/2993/Butter%20Prices%20and%20Sales\" %&gt;%\n  httr2::request()\n\n\n\nThis creates an object called req which can then be passed to the httr2::req_perform() function to execute the request. The req object includes the URL:\n\n\n&lt;httr2_request&gt;\nGET https://mpr.datamart.ams.usda.gov/services/v1.1/reports/2993/Butter%20Prices%20and%20Sales\nBody: empty"
  },
  {
    "objectID": "index.html#creating-a-httr2-request-1",
    "href": "index.html#creating-a-httr2-request-1",
    "title": "Working with APIs in R",
    "section": "Creating a httr2 Request",
    "text": "Creating a httr2 Request\n\nBuilding the URL piece-by-piece can be helpful when it is more complex or lengthy. This can make the code more readable for the end user. It also helps when you have a situation with a lot of query parameters.\nWe start with the same idea, passing a URL to the httr2::request() function. However, here we use the base URL for the Datamart API.\nThe req_url_path_append() function lets us specify strings to add to the end of the base URL passed to request(). Arguments that are separated by a comma in the function will be separated by a slash in the URL. In this case, I am using the URLencode() function so I don’t have to type out the %20s to replace the spaces in the “Butter Prices and Sales” string.\nThis is also where I ran into trouble before when the httr2 code changed in development. In an earlier version of httr2, the req_url_path_append() function would automatically encode strings before they were added to the URL. However, this apparently resulted in problems in certain cases, with characters accidentally double-encoded or incorrectly encoded. The function was changed to take the string verbatim, but it needs to be encoded properly for the request to be executed. When this changed it broke some of my code.\nFinally, the req_url_query() function helps us to add query parameters at the end of the URL. In this case I am adding a parameter, lastReports = 1 to only pull data from the most recent NDPSR report. This is mostly to simplify the results. req_url_query() adds a question mark automatically and separates arguments with ampersands.\n\nHowever, it can be helpful to build the request piece by piece (especially with a lengthy URL like this one). httr2 also includes a suite of functions to do so:\n\nreq &lt;- \"https://mpr.datamart.ams.usda.gov/services/v1.1/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\n    \"2993\",\n    URLencode(\"Butter Prices and Sales\")\n  ) %&gt;%\n  httr2::req_url_query(\n    lastReports = 1\n  )\n\n\nThe result is the same (or close enough; I added the lastReports parameter):\n\n\n&lt;httr2_request&gt;\nGET https://mpr.datamart.ams.usda.gov/services/v1.1/reports/2993/Butter%20Prices%20and%20Sales?lastReports=1\nBody: empty"
  },
  {
    "objectID": "index.html#executing-a-request-and-receiving-a-response",
    "href": "index.html#executing-a-request-and-receiving-a-response",
    "title": "Working with APIs in R",
    "section": "Executing a Request and Receiving a Response",
    "text": "Executing a Request and Receiving a Response\nA request object is passed to httr2::req_perform() to actually execute the request:\n\nresp &lt;- req %&gt;%\n  httr2::req_perform()\n\n\nThe response object resp is another list containing some pertinent information:\n\n\n&lt;httr2_response&gt;\nGET https://mpr.datamart.ams.usda.gov/services/v1.1/reports/2993/Butter%20Prices%20and%20Sales?lastReports=1\nStatus: 200 OK\nContent-Type: application/json\nBody: In memory (3928 bytes)\n\n\n\n\n\n\nThe HTTP verb and URL used in the request.\nStatus: The HTTP status code. A 200 response indicates the request was successful; a code in the 400 or 500 range indicates a server error, and httr2 will convert these to R errors automatically.\nContent-Type: Indicates the content returned is in JSON format.\nBody: Tells us there is 3.93 kB of data in memory.\n\n\n\nAs a side note, you can execute a request without creating an explicit request object or response object, i.e., without creating req and resp. I personally find it helpful, especially when learning how to use a new API.\nIf preferred, you can simply pipe a URL into httr2::request() and then pipe directly into httr2::req_perform(). It still may be helpful to save the response so you don’t have to call the API server more often than necessary."
  },
  {
    "objectID": "index.html#extracting-data-from-a-response",
    "href": "index.html#extracting-data-from-a-response",
    "title": "Working with APIs in R",
    "section": "Extracting Data from a Response",
    "text": "Extracting Data from a Response\n\nScroll through the list output.\nThe list consists of four top-level items: reportSection, the name of the report section returned, reportSections, the names of all report sections for the specific slug ID, stats, another list containing some information on the results.\nThe results element is clearly what we are interested in. We can see it is itself a list with five elements, each of which is another list (JSON data is often a lot of nested lists) with 19 elements each. The 19 elements in the lower-level lists look like variables, including names and data types, and values. We can start to see the data structure here: a data frame with 5 rows and 19 variables.\n\nData are saved in the body of the response object and can be extracted using a set of functions from httr2 depending on the format of the data.\n\nSince our data are in JSON format, we can pass resp to httr2::resp_body_json(). The full JSON data prints by default, which is a lot of output. It can be helpful to use the str() function to look at the structure of the data first (which still produces a lot of output):\n\nresp %&gt;%\n  httr2::resp_body_json() %&gt;%\n  str()\n\nList of 4\n $ reportSection : chr \"Butter Prices and Sales\"\n $ reportSections:List of 11\n  ..$ : chr \"Summary\"\n  ..$ : chr \"Butter Prices and Sales\"\n  ..$ : chr \"40 Pound Block Cheddar Cheese Prices and Sales\"\n  ..$ : chr \"500 Pound Barrel Cheddar Cheese Prices, Sales, and Moisture Content\"\n  ..$ : chr \"Dry Whey Prices and Sales\"\n  ..$ : chr \"Nonfat Dry Milk Prices and Sales\"\n  ..$ : chr \"Final Butter Prices and Sales\"\n  ..$ : chr \"Final 40 Pound Block Cheddar Cheese Prices and Sales\"\n  ..$ : chr \"Final 500 Pound Barrel Cheddar Cheese Prices, Sales, and Moisture Content\"\n  ..$ : chr \"Final Dry Whey Prices and Sales\"\n  ..$ : chr \"Final Nonfat Dry Milk Prices and Sales\"\n $ stats         :List of 3\n  ..$ totalRows:      : int 5\n  ..$ returnedRows:   : int 5\n  ..$ userAllowedRows:: int 99999\n $ results       :List of 5\n  ..$ :List of 19\n  .. ..$ week_ending_date     : chr \"01/31/2026\"\n  .. ..$ created_date         : chr \"02/04/2026\"\n  .. ..$ narrative            : NULL\n  .. ..$ Week Ending Date     : chr \"01/03/2026\"\n  .. ..$ Butter_Price         : chr \"1.4318\"\n  .. ..$ Butter_Sales         : chr \"8,382,733\"\n  .. ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  .. ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  .. ..$ slug_id              : chr \"2993\"\n  .. ..$ office_name          : chr \"Dairy MMR\"\n  .. ..$ office_code          : chr \"DY-WA\"\n  .. ..$ office_city          : chr \"Washington\"\n  .. ..$ office_state         : chr \"DC\"\n  .. ..$ market_location_name : chr \"Washington, DC\"\n  .. ..$ market_location_city : chr \"Washington\"\n  .. ..$ market_location_state: chr \"DC\"\n  .. ..$ market_type          : chr \"FMMOS\"\n  .. ..$ market_type_category : chr \"FMMOS - non-mars\"\n  .. ..$ published_date       : chr \"02/04/2026 13:00:47\"\n  ..$ :List of 19\n  .. ..$ week_ending_date     : chr \"01/31/2026\"\n  .. ..$ created_date         : chr \"02/04/2026\"\n  .. ..$ narrative            : NULL\n  .. ..$ Week Ending Date     : chr \"01/10/2026\"\n  .. ..$ Butter_Price         : chr \"1.4241\"\n  .. ..$ Butter_Sales         : chr \"3,028,640\"\n  .. ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  .. ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  .. ..$ slug_id              : chr \"2993\"\n  .. ..$ office_name          : chr \"Dairy MMR\"\n  .. ..$ office_code          : chr \"DY-WA\"\n  .. ..$ office_city          : chr \"Washington\"\n  .. ..$ office_state         : chr \"DC\"\n  .. ..$ market_location_name : chr \"Washington, DC\"\n  .. ..$ market_location_city : chr \"Washington\"\n  .. ..$ market_location_state: chr \"DC\"\n  .. ..$ market_type          : chr \"FMMOS\"\n  .. ..$ market_type_category : chr \"FMMOS - non-mars\"\n  .. ..$ published_date       : chr \"02/04/2026 13:00:47\"\n  ..$ :List of 19\n  .. ..$ week_ending_date     : chr \"01/31/2026\"\n  .. ..$ created_date         : chr \"02/04/2026\"\n  .. ..$ narrative            : NULL\n  .. ..$ Week Ending Date     : chr \"01/17/2026\"\n  .. ..$ Butter_Price         : chr \"1.4130\"\n  .. ..$ Butter_Sales         : chr \"3,890,546\"\n  .. ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  .. ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  .. ..$ slug_id              : chr \"2993\"\n  .. ..$ office_name          : chr \"Dairy MMR\"\n  .. ..$ office_code          : chr \"DY-WA\"\n  .. ..$ office_city          : chr \"Washington\"\n  .. ..$ office_state         : chr \"DC\"\n  .. ..$ market_location_name : chr \"Washington, DC\"\n  .. ..$ market_location_city : chr \"Washington\"\n  .. ..$ market_location_state: chr \"DC\"\n  .. ..$ market_type          : chr \"FMMOS\"\n  .. ..$ market_type_category : chr \"FMMOS - non-mars\"\n  .. ..$ published_date       : chr \"02/04/2026 13:00:47\"\n  ..$ :List of 19\n  .. ..$ week_ending_date     : chr \"01/31/2026\"\n  .. ..$ created_date         : chr \"02/04/2026\"\n  .. ..$ narrative            : NULL\n  .. ..$ Week Ending Date     : chr \"01/24/2026\"\n  .. ..$ Butter_Price         : chr \"1.3655\"\n  .. ..$ Butter_Sales         : chr \"3,605,670\"\n  .. ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  .. ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  .. ..$ slug_id              : chr \"2993\"\n  .. ..$ office_name          : chr \"Dairy MMR\"\n  .. ..$ office_code          : chr \"DY-WA\"\n  .. ..$ office_city          : chr \"Washington\"\n  .. ..$ office_state         : chr \"DC\"\n  .. ..$ market_location_name : chr \"Washington, DC\"\n  .. ..$ market_location_city : chr \"Washington\"\n  .. ..$ market_location_state: chr \"DC\"\n  .. ..$ market_type          : chr \"FMMOS\"\n  .. ..$ market_type_category : chr \"FMMOS - non-mars\"\n  .. ..$ published_date       : chr \"02/04/2026 13:00:47\"\n  ..$ :List of 19\n  .. ..$ week_ending_date     : chr \"01/31/2026\"\n  .. ..$ created_date         : chr \"02/04/2026\"\n  .. ..$ narrative            : NULL\n  .. ..$ Week Ending Date     : chr \"01/31/2026\"\n  .. ..$ Butter_Price         : chr \"1.4962\"\n  .. ..$ Butter_Sales         : chr \"3,415,627\"\n  .. ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  .. ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  .. ..$ slug_id              : chr \"2993\"\n  .. ..$ office_name          : chr \"Dairy MMR\"\n  .. ..$ office_code          : chr \"DY-WA\"\n  .. ..$ office_city          : chr \"Washington\"\n  .. ..$ office_state         : chr \"DC\"\n  .. ..$ market_location_name : chr \"Washington, DC\"\n  .. ..$ market_location_city : chr \"Washington\"\n  .. ..$ market_location_state: chr \"DC\"\n  .. ..$ market_type          : chr \"FMMOS\"\n  .. ..$ market_type_category : chr \"FMMOS - non-mars\"\n  .. ..$ published_date       : chr \"02/04/2026 13:00:47\""
  },
  {
    "objectID": "index.html#extracting-data-purrrpluck",
    "href": "index.html#extracting-data-purrrpluck",
    "title": "Working with APIs in R",
    "section": "Extracting Data: purrr::pluck()",
    "text": "Extracting Data: purrr::pluck()\nWe can use the pluck() function from the purrr package (part of the tidyverse) to extract just the results object from the larger list.\n\nresp %&gt;%\n  httr2::resp_body_json() %&gt;%\n  pluck(\"results\") %&gt;%\n  str()\n\nList of 5\n $ :List of 19\n  ..$ week_ending_date     : chr \"01/31/2026\"\n  ..$ created_date         : chr \"02/04/2026\"\n  ..$ narrative            : NULL\n  ..$ Week Ending Date     : chr \"01/03/2026\"\n  ..$ Butter_Price         : chr \"1.4318\"\n  ..$ Butter_Sales         : chr \"8,382,733\"\n  ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  ..$ slug_id              : chr \"2993\"\n  ..$ office_name          : chr \"Dairy MMR\"\n  ..$ office_code          : chr \"DY-WA\"\n  ..$ office_city          : chr \"Washington\"\n  ..$ office_state         : chr \"DC\"\n  ..$ market_location_name : chr \"Washington, DC\"\n  ..$ market_location_city : chr \"Washington\"\n  ..$ market_location_state: chr \"DC\"\n  ..$ market_type          : chr \"FMMOS\"\n  ..$ market_type_category : chr \"FMMOS - non-mars\"\n  ..$ published_date       : chr \"02/04/2026 13:00:47\"\n $ :List of 19\n  ..$ week_ending_date     : chr \"01/31/2026\"\n  ..$ created_date         : chr \"02/04/2026\"\n  ..$ narrative            : NULL\n  ..$ Week Ending Date     : chr \"01/10/2026\"\n  ..$ Butter_Price         : chr \"1.4241\"\n  ..$ Butter_Sales         : chr \"3,028,640\"\n  ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  ..$ slug_id              : chr \"2993\"\n  ..$ office_name          : chr \"Dairy MMR\"\n  ..$ office_code          : chr \"DY-WA\"\n  ..$ office_city          : chr \"Washington\"\n  ..$ office_state         : chr \"DC\"\n  ..$ market_location_name : chr \"Washington, DC\"\n  ..$ market_location_city : chr \"Washington\"\n  ..$ market_location_state: chr \"DC\"\n  ..$ market_type          : chr \"FMMOS\"\n  ..$ market_type_category : chr \"FMMOS - non-mars\"\n  ..$ published_date       : chr \"02/04/2026 13:00:47\"\n $ :List of 19\n  ..$ week_ending_date     : chr \"01/31/2026\"\n  ..$ created_date         : chr \"02/04/2026\"\n  ..$ narrative            : NULL\n  ..$ Week Ending Date     : chr \"01/17/2026\"\n  ..$ Butter_Price         : chr \"1.4130\"\n  ..$ Butter_Sales         : chr \"3,890,546\"\n  ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  ..$ slug_id              : chr \"2993\"\n  ..$ office_name          : chr \"Dairy MMR\"\n  ..$ office_code          : chr \"DY-WA\"\n  ..$ office_city          : chr \"Washington\"\n  ..$ office_state         : chr \"DC\"\n  ..$ market_location_name : chr \"Washington, DC\"\n  ..$ market_location_city : chr \"Washington\"\n  ..$ market_location_state: chr \"DC\"\n  ..$ market_type          : chr \"FMMOS\"\n  ..$ market_type_category : chr \"FMMOS - non-mars\"\n  ..$ published_date       : chr \"02/04/2026 13:00:47\"\n $ :List of 19\n  ..$ week_ending_date     : chr \"01/31/2026\"\n  ..$ created_date         : chr \"02/04/2026\"\n  ..$ narrative            : NULL\n  ..$ Week Ending Date     : chr \"01/24/2026\"\n  ..$ Butter_Price         : chr \"1.3655\"\n  ..$ Butter_Sales         : chr \"3,605,670\"\n  ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  ..$ slug_id              : chr \"2993\"\n  ..$ office_name          : chr \"Dairy MMR\"\n  ..$ office_code          : chr \"DY-WA\"\n  ..$ office_city          : chr \"Washington\"\n  ..$ office_state         : chr \"DC\"\n  ..$ market_location_name : chr \"Washington, DC\"\n  ..$ market_location_city : chr \"Washington\"\n  ..$ market_location_state: chr \"DC\"\n  ..$ market_type          : chr \"FMMOS\"\n  ..$ market_type_category : chr \"FMMOS - non-mars\"\n  ..$ published_date       : chr \"02/04/2026 13:00:47\"\n $ :List of 19\n  ..$ week_ending_date     : chr \"01/31/2026\"\n  ..$ created_date         : chr \"02/04/2026\"\n  ..$ narrative            : NULL\n  ..$ Week Ending Date     : chr \"01/31/2026\"\n  ..$ Butter_Price         : chr \"1.4962\"\n  ..$ Butter_Sales         : chr \"3,415,627\"\n  ..$ report_title         : chr \"National Dairy Products Sales Report (PDF)\"\n  ..$ slug_name            : chr \"DYWDAIRYPRODUCTSSALES\"\n  ..$ slug_id              : chr \"2993\"\n  ..$ office_name          : chr \"Dairy MMR\"\n  ..$ office_code          : chr \"DY-WA\"\n  ..$ office_city          : chr \"Washington\"\n  ..$ office_state         : chr \"DC\"\n  ..$ market_location_name : chr \"Washington, DC\"\n  ..$ market_location_city : chr \"Washington\"\n  ..$ market_location_state: chr \"DC\"\n  ..$ market_type          : chr \"FMMOS\"\n  ..$ market_type_category : chr \"FMMOS - non-mars\"\n  ..$ published_date       : chr \"02/04/2026 13:00:47\"\n\n\nBut this still results in a list, which we have to work to convert to a data frame. What gives?\n\nExtracting just the results list from the JSON data is better, but still results in a list. There are ways to work this into a data frame, but the narrative variable being NULL causes some issues for us. Fortunately, there is a simpler approach."
  },
  {
    "objectID": "index.html#an-alternative-approach",
    "href": "index.html#an-alternative-approach",
    "title": "Working with APIs in R",
    "section": "An Alternative Approach",
    "text": "An Alternative Approach\nSetting the simplifyVector argument in httr2::resp_body_json() to TRUE causes it to behave exactly like jsonlite::fromJSON():\n\nresp %&gt;%\n  httr2::resp_body_json(simplifyVector = TRUE) %&gt;%\n  pluck(\"results\")\n\n\n  \n\n\n\nAnd returns a nicely formatted data frame when we use purrr::pluck() to isolate the results.\n\nThe httr2::resp_body_json() function uses jsonlite::fromJSON() under the hood, but it changes the default value of simplifyVector from TRUE in jsonlite::fromJSON() to FALSE. This changes the behavior somewhat.\nI assume the httr2 developers have a good reason for doing this, but I find just setting simplifyVector = TRUE to often be an easier approach."
  },
  {
    "objectID": "index.html#putting-it-all-together",
    "href": "index.html#putting-it-all-together",
    "title": "Working with APIs in R",
    "section": "Putting It All Together",
    "text": "Putting It All Together\n\nFirst we pass the base URL for the API service to the httr2::request() function.\nNext, we use httr2::req_url_path_append() and httr2::req_url_query() to define the API endpoint (the specific report and section we want) and any query parameters.\nThen the request object is passed to httr2::req_perform() to execute, creating the resp object.\nFinally, the data are extracted from the response object using httr2::resp_body_json() and purrr::pluck().\n\nWe just covered a lot of different functions and syntax. Let’s see the full API call together.\n\n\nreq &lt;- \"https://mpr.datamart.ams.usda.gov/services/v1.1/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\n    \"2993\",\n    URLencode(\"Butter Prices and Sales\")\n  ) %&gt;%\n  httr2::req_url_query(\n    lastReports = 1\n  )\n\nresp &lt;- req %&gt;%\n  httr2::req_perform()\n\ndata &lt;- resp %&gt;%\n  httr2::resp_body_json(simplifyVector = TRUE) %&gt;%\n  pluck(\"results\")\n\n\n\nGreat, we have butter prices and sales data! But what about the other products? Do we have to do all of that again?"
  },
  {
    "objectID": "index.html#functions-allow-greater-flexibility",
    "href": "index.html#functions-allow-greater-flexibility",
    "title": "Working with APIs in R",
    "section": "Functions Allow Greater Flexibility",
    "text": "Functions Allow Greater Flexibility\nIf you suspect you’ll be using a specific API regularly, especially if you’ll being varying the parameters, build a function."
  },
  {
    "objectID": "index.html#identify-function-arguments",
    "href": "index.html#identify-function-arguments",
    "title": "Working with APIs in R",
    "section": "Identify Function Arguments",
    "text": "Identify Function Arguments\nThe first step is to look at the API call and identify which parts the user may want to change. Those elements will become our function arguments.\n\n\nreq &lt;- \"https://mpr.datamart.ams.usda.gov/services/v1.1/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\n    \"2993\",\n    URLencode(\"Butter Prices and Sales\")\n  ) %&gt;%\n  httr2::req_url_query(\n    lastReports = 1\n  )\n\n\nSlug ID: “2993” is the slug ID for the NDPSR, but a user may want to pull a different report.\nSection Name: A section name argument allows the user to pull different sections from a given report.\nlastReports Parameter: Allows the user to select how many recent reports to return."
  },
  {
    "objectID": "index.html#datamart-api-function",
    "href": "index.html#datamart-api-function",
    "title": "Working with APIs in R",
    "section": "Datamart API Function",
    "text": "Datamart API Function\n\nslugid is set as the first argument and is not given a default. We want the user to specify this one.\nsection is the second argument, and is given a default value of NULL. Not all reports in Datamart have different sections, and a user may want to pull the full metadata for a report. This also leverages how httr2 treats NULL values in the httr2::req_url_path_append() and httr2::req_url_query() functions. If a NULL value is provided it is simply ignored (or removed if already present).\nlastReports is the last argument, and is given a default value of 1. This means only the most recent report will be pulled by default. This protects the user (and the server) from being overwhelmed by large requests.\n\nWith those arguments in mind, we can start building a function:\n\n\nDatamart_Pull &lt;- function(\n    slugid,\n    section = NULL,\n    lastReports = 1\n) {\n  \n  # Code goes here...\n  \n}"
  },
  {
    "objectID": "index.html#datamart-api-function-1",
    "href": "index.html#datamart-api-function-1",
    "title": "Working with APIs in R",
    "section": "Datamart API Function",
    "text": "Datamart API Function\nNext we add our code to generate the request and extract the results:\n\nDatamart_Pull &lt;- function(\n    slugid,\n    section = NULL,\n    lastReports = 1\n) {\n  \n  # First set the base URL for the Datamart/LMPR API\n  base_url &lt;- \"https://mpr.datamart.ams.usda.gov/services/v1.1/reports\"\n  \n  # URL Encode Section Name\n  if (!is.null(section)) {\n    section &lt;- URLencode(section)\n  }\n  \n  # Next, define the API request (whether or not section is specified)\n  req &lt;- base_url |&gt;\n    httr2::request() |&gt;\n    httr2::req_url_path_append(slugid, section) |&gt;\n    httr2::req_url_query(lastReports = lastReports)\n  \n  # Perform the API call and convert the response to JSON format\n  resp &lt;- req |&gt;\n    httr2::req_perform()\n  \n  data &lt;- resp |&gt;\n    httr2::resp_body_json(simplifyVector = TRUE) |&gt;\n    purrr::pluck(\"results\") |&gt;\n    as_tibble()\n  \n}\n\n\nWe set the base_url to the common URL used for all Datamart API calls. This can be hardcoded since it is not going to change.\nNext, we use URLencode() to make sure the section name is properly formatted, given that we know the Datamart report section names often include spaces.\nThen we define the httr2 request object. We use httr2::req_url_path_append to append the slugid argument and section argument to the end of the URL, then use httr2::req_url_query to set the lastReports query parameter.\nFinally, the request is executed and the results are extracted and saved as a tibble.\nBy assigning the results to the data object, the Datamart_Pull() function will not print the results when run. It will assign the results to a new object though. This is to save the user from accidentally printing a ton of output to the console."
  },
  {
    "objectID": "index.html#datamart_pull-in-action",
    "href": "index.html#datamart_pull-in-action",
    "title": "Working with APIs in R",
    "section": "Datamart_Pull() in Action",
    "text": "Datamart_Pull() in Action\nLet’s use the new Datamart_Pull() function to pull cheese prices from the last four reports:\n\n\nDatamart_Pull(slugid = \"2993\",\n              section = \"40 Pound Block Cheddar Cheese Prices and Sales\",\n              lastReports = 4) %&gt;%\n  select(Report_Week = week_ending_date, Week_Ending = `Week Ending Date`, cheese_40_Price, cheese_40_Sales)\n\n\n  \n\n\n\n\nNow that we have this code wrapped up in a function, it is a lot easier to use for different purposes. We easily swapped out the section name to get a different set of prices and changed the lastReports parameter to pull more data."
  },
  {
    "objectID": "index.html#utilizing-purrrmap",
    "href": "index.html#utilizing-purrrmap",
    "title": "Working with APIs in R",
    "section": "Utilizing purrr::map()",
    "text": "Utilizing purrr::map()\nSince we might want to pull all the product prices at the same time, we can utilize the map() function from the purrr package to iterate over a list:\n\nlist(\n  \"Butter Prices and Sales\",\n  \"40 Pound Block Cheddar Cheese Prices and Sales\",\n  \"Dry Whey Prices and Sales\",\n  \"Nonfat Dry Milk Prices and Sales\"\n)\n\n\nI admit this next bit might be getting a bit advanced, but I think it is a really important concept to discuss briefly.\nA huge benefit of writing your own functions is using those functions to iterate over lists. If we wanted to pull all of the product price data at once, we can pass a list of the four different section names to the map() function and apply Datamart_Pull() to each element of the list.\nWe start by defining a list with all of the section names."
  },
  {
    "objectID": "index.html#utilizing-purrrmap-1",
    "href": "index.html#utilizing-purrrmap-1",
    "title": "Working with APIs in R",
    "section": "Utilizing purrr::map()",
    "text": "Utilizing purrr::map()\nSince we might want to pull all the product prices at the same time, we can utilize the map() function from the purrr package to iterate over a list:\n\nlist(\n  \"Butter Prices and Sales\",\n  \"40 Pound Block Cheddar Cheese Prices and Sales\",\n  \"Dry Whey Prices and Sales\",\n  \"Nonfat Dry Milk Prices and Sales\"\n) %&gt;%\n  map(\n    \\(x) Datamart_Pull(slugid = \"2993\", section = x)\n  ) \n\n[[1]]\n# A tibble: 5 × 19\n  week_ending_date created_date narrative `Week Ending Date` Butter_Price\n  &lt;chr&gt;            &lt;chr&gt;        &lt;lgl&gt;     &lt;chr&gt;              &lt;chr&gt;       \n1 01/31/2026       02/04/2026   NA        01/03/2026         1.4318      \n2 01/31/2026       02/04/2026   NA        01/10/2026         1.4241      \n3 01/31/2026       02/04/2026   NA        01/17/2026         1.4130      \n4 01/31/2026       02/04/2026   NA        01/24/2026         1.3655      \n5 01/31/2026       02/04/2026   NA        01/31/2026         1.4962      \n# ℹ 14 more variables: Butter_Sales &lt;chr&gt;, report_title &lt;chr&gt;, slug_name &lt;chr&gt;,\n#   slug_id &lt;chr&gt;, office_name &lt;chr&gt;, office_code &lt;chr&gt;, office_city &lt;chr&gt;,\n#   office_state &lt;chr&gt;, market_location_name &lt;chr&gt;, market_location_city &lt;chr&gt;,\n#   market_location_state &lt;chr&gt;, market_type &lt;chr&gt;, market_type_category &lt;chr&gt;,\n#   published_date &lt;chr&gt;\n\n[[2]]\n# A tibble: 5 × 19\n  week_ending_date created_date narrative `Week Ending Date` cheese_40_Price\n  &lt;chr&gt;            &lt;chr&gt;        &lt;lgl&gt;     &lt;chr&gt;              &lt;chr&gt;          \n1 01/31/2026       02/04/2026   NA        01/03/2026         1.4174         \n2 01/31/2026       02/04/2026   NA        01/10/2026         1.4126         \n3 01/31/2026       02/04/2026   NA        01/17/2026         1.4015         \n4 01/31/2026       02/04/2026   NA        01/24/2026         1.3873         \n5 01/31/2026       02/04/2026   NA        01/31/2026         1.3805         \n# ℹ 14 more variables: cheese_40_Sales &lt;chr&gt;, report_title &lt;chr&gt;,\n#   slug_name &lt;chr&gt;, slug_id &lt;chr&gt;, office_name &lt;chr&gt;, office_code &lt;chr&gt;,\n#   office_city &lt;chr&gt;, office_state &lt;chr&gt;, market_location_name &lt;chr&gt;,\n#   market_location_city &lt;chr&gt;, market_location_state &lt;chr&gt;, market_type &lt;chr&gt;,\n#   market_type_category &lt;chr&gt;, published_date &lt;chr&gt;\n\n[[3]]\n# A tibble: 5 × 19\n  week_ending_date created_date narrative `Week Ending Date` whey_Price\n  &lt;chr&gt;            &lt;chr&gt;        &lt;lgl&gt;     &lt;chr&gt;              &lt;chr&gt;     \n1 01/31/2026       02/04/2026   NA        01/03/2026         0.7040    \n2 01/31/2026       02/04/2026   NA        01/10/2026         0.7072    \n3 01/31/2026       02/04/2026   NA        01/17/2026         0.7013    \n4 01/31/2026       02/04/2026   NA        01/24/2026         0.6986    \n5 01/31/2026       02/04/2026   NA        01/31/2026         0.6861    \n# ℹ 14 more variables: whey_Sales &lt;chr&gt;, report_title &lt;chr&gt;, slug_name &lt;chr&gt;,\n#   slug_id &lt;chr&gt;, office_name &lt;chr&gt;, office_code &lt;chr&gt;, office_city &lt;chr&gt;,\n#   office_state &lt;chr&gt;, market_location_name &lt;chr&gt;, market_location_city &lt;chr&gt;,\n#   market_location_state &lt;chr&gt;, market_type &lt;chr&gt;, market_type_category &lt;chr&gt;,\n#   published_date &lt;chr&gt;\n\n[[4]]\n# A tibble: 5 × 19\n  week_ending_date created_date narrative `Week Ending Date` nonfat_milk_Price\n  &lt;chr&gt;            &lt;chr&gt;        &lt;lgl&gt;     &lt;chr&gt;              &lt;chr&gt;            \n1 01/31/2026       02/04/2026   NA        01/03/2026         1.1648           \n2 01/31/2026       02/04/2026   NA        01/10/2026         1.1794           \n3 01/31/2026       02/04/2026   NA        01/17/2026         1.1914           \n4 01/31/2026       02/04/2026   NA        01/24/2026         1.2032           \n5 01/31/2026       02/04/2026   NA        01/31/2026         1.2197           \n# ℹ 14 more variables: nonfat_milk_Sales &lt;chr&gt;, report_title &lt;chr&gt;,\n#   slug_name &lt;chr&gt;, slug_id &lt;chr&gt;, office_name &lt;chr&gt;, office_code &lt;chr&gt;,\n#   office_city &lt;chr&gt;, office_state &lt;chr&gt;, market_location_name &lt;chr&gt;,\n#   market_location_city &lt;chr&gt;, market_location_state &lt;chr&gt;, market_type &lt;chr&gt;,\n#   market_type_category &lt;chr&gt;, published_date &lt;chr&gt;\n\n\n\nThen, this list is passed into the map() function.\nmap() takes a list or vector as its first argument, which is exactly what we are piping in.\nThe second argument is a function to apply to each element of the list. In this case we define the function using an anonymous function. The anonymous function allows us to plug x into the section argument in Datamart_Pull(). The slugid argument is hardcoded because we are pulling from the same report.\nThe result is a list with four elements, each of which is a tibble containing the requested data (scroll through to show this)."
  },
  {
    "objectID": "index.html#utilizing-purrrmap-2",
    "href": "index.html#utilizing-purrrmap-2",
    "title": "Working with APIs in R",
    "section": "Utilizing purrr::map()",
    "text": "Utilizing purrr::map()\nSince we might want to pull all the product prices at the same time, we can utilize the map() function from the purrr package to iterate over a list:\n\nlist(\n  \"Butter Prices and Sales\",\n  \"40 Pound Block Cheddar Cheese Prices and Sales\",\n  \"Dry Whey Prices and Sales\",\n  \"Nonfat Dry Milk Prices and Sales\"\n) %&gt;%\n  map(\n    \\(x) Datamart_Pull(slugid = \"2993\", section = x)\n  ) %&gt;%\n  map(\n    \\(x) select(x, -c(created_date, narrative, report_title:published_date))\n  ) %&gt;%\n  reduce(left_join, by = c(\"week_ending_date\", \"Week Ending Date\"))\n\n\n  \n\n\n\n\nSince we still have a list object, we can pass it into another map() call. Here I am just dropping a few unneccessary variables.\nI then combine the tibbles into a single tibble using the reduce() function and a left_join on the two date variables.\nThe result is a single tibble containing prices and sales data for all four products.\nOne thing to note is that these are all character type variables. So we still have some data cleaning steps before we can start working with the data."
  },
  {
    "objectID": "index.html#further-improvements",
    "href": "index.html#further-improvements",
    "title": "Working with APIs in R",
    "section": "Further Improvements",
    "text": "Further Improvements\nThe Datamart_Pull() function we’ve built is fairly bare bones, but it gets the job done. There are several potential improvements that could make it more user friendly and foolproof:\n\nCheck the argument types and throw a helpful error if there is a type mismatch.\nCreate specific functions for each endpoint: Define a new function for just the NDPSR (slug ID 2993) so the user does not need to know more about the details of the API.\nAllow more arguments: The Datamart API allows more query parameters in addition to lastReports, such as filtering by a date. Include more arguments for the user to set (which might be easier with specific functions for each endpoint).\nBuild a package!"
  },
  {
    "objectID": "index.html#what-is-authentication",
    "href": "index.html#what-is-authentication",
    "title": "Working with APIs in R",
    "section": "What is Authentication?",
    "text": "What is Authentication?\n\nThere is technically a distinction between “authentication” and “authorization”, but it likely does not matter for most of our use cases. An example would be if an API restricts access to certain data to only senior-level members of an organization. In this case, a user may be authenticated properly but not authorized for a certain request.\n\nDatamart is a fairly simple API since it does not require authentication to use. However, many APIs require users to be authenticated and authorized before they will return data.\n\nAuthentication is the process by which an application confirms a user’s identity.\nAuthorization is a further step which confirms whether an authenticated user is authorized to access the requested information.\n\n\nAuthentication is often handled by assigning an API key, an alphanumeric combination unique to each user. In some cases, users may use a username and password for authentication.\n\n\nRequiring authentication helps APIs manage access by tracking usage and enforcing limits. Even if it is free to sign up for an API key, they ensure an extra layer of security."
  },
  {
    "objectID": "index.html#another-scenario-my-market-news",
    "href": "index.html#another-scenario-my-market-news",
    "title": "Working with APIs in R",
    "section": "Another Scenario: My Market News",
    "text": "Another Scenario: My Market News\n\nMy Market News includes data from Cotton & Tobacco Market News; Dairy Market News; Livestock, Poultry, and Grain Market News; and Specialty Crops Market News.\n\n\n\nMy Market News is another AMS website hosting data from across Market News divisions.\nMy Market News also has an API service, with documentation available. The My Market News API requires users to have an API key.\nLet’s use the My Market News API to pull some more dairy data."
  },
  {
    "objectID": "index.html#secret-management",
    "href": "index.html#secret-management",
    "title": "Working with APIs in R",
    "section": "Secret Management",
    "text": "Secret Management\nAPI keys are considered secrets in computer science parlance.\n\nSecrets are sensitive information a user wants to keep secret. When transmitting a secret over the internet (as we do when making HTTP requests), so additional care is required.\n\n\nThe easiest way to manage API keys for use in R is to store them in an .Renviron file. .Renviron is read by R on startup, creating environmental variables that are accessible in an R session with Sys.getenv().\n\n\nEnvironmental variables are saved as key-value pairs. .Renviron is easily accessed with the usethis::edit_r_environ() function.\n\n\n.Renviron\n\nNASSQS_TOKEN=\"abc123\"\nMMN_API_KEY=\"def456\"\nFRED_API_KEY=\"ghi789\"\nCENSUS_API_KEY=\"jkl101112\""
  },
  {
    "objectID": "index.html#using-the-my-market-news-api",
    "href": "index.html#using-the-my-market-news-api",
    "title": "Working with APIs in R",
    "section": "Using the My Market News API",
    "text": "Using the My Market News API\nLet’s try to pull prices for Oceania Whole Milk Powder.\nAs we did with the Datamart API, we start by building a httr2 request:\n\nreq &lt;- \"https://marsapi.ams.usda.gov/services/v1.2/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\"1039\")"
  },
  {
    "objectID": "index.html#using-the-my-market-news-api-1",
    "href": "index.html#using-the-my-market-news-api-1",
    "title": "Working with APIs in R",
    "section": "Using the My Market News API",
    "text": "Using the My Market News API\nLet’s try to pull prices for Oceania Whole Milk Powder.\nAs we did with the Datamart API, we start by building a httr2 request:\n\nreq &lt;- \"https://marsapi.ams.usda.gov/services/v1.2/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\"1039\")\n\nresp &lt;- req %&gt;%\n  httr2::req_perform()\n\nError in `httr2::req_perform()`:\n! HTTP 403 Forbidden.\n\n\n\nUh oh, an error!"
  },
  {
    "objectID": "index.html#what-caused-the-error",
    "href": "index.html#what-caused-the-error",
    "title": "Working with APIs in R",
    "section": "What caused the error?",
    "text": "What caused the error?\n\nEven though the culprit behind this error is pretty obvious (we didn’t actually use our API key), this is a good opportunity to investigate how to look into an error message in further detail.\nWhen we look at the $message and $detail elements of the JSON list that was returned, we can see “Access is denied” due to not being authenticated. We can remedy this easily by using our API key.\nhttr2 also has tools for building more informative error messages, which will print properly in the R console, for any functions you build.\n\nSometimes you will need to investigate what is causing an error more closely. Luckily, httr2 allows us to do so even if the request failed.\n\nThe httr2::last_response() function will return the response object even if an error caused the code to fail. We can read the contents using httr2::resp_body_json():\n\n\n\nhttr2::last_response() %&gt;%\n  httr2::resp_body_json()\n\n$status\n[1] \"403 - Forbidden\"\n\n$errorCode\n[1] 403\n\n$message\n[1] \"Access is denied\"\n\n$detail\n[1] \"Attempt to access the protected resource. Please use HELP LINK for more information: https://marsapi.ams.usda.gov/services/help\"\n\n$dateTime\n[1] \"2026-02-05T09:44:58.7690015\""
  },
  {
    "objectID": "index.html#using-my-market-news-api-with-authentication",
    "href": "index.html#using-my-market-news-api-with-authentication",
    "title": "Working with APIs in R",
    "section": "Using My Market News API with Authentication",
    "text": "Using My Market News API with Authentication\n\nThe My Market News API uses basic authentication, so we can use the httr2::req_auth_basic() function to set our API key. I’m using Sys.getenv() to pull my API key from my .Renviron file.\nYou’ll notice I’m setting my API key as both the username and password in httr2::req_auth_basic(). This may seem redundant, but its due to a bit of a quirk from both the My Market News API and the way the httr2 function works.\nThe My Market News documentation says to use the API key as the basic authentication username value, and says a password is not required. Which suggests we could just set the username argument in httr2::req_auth_basic(). However, the httr2::req_auth_basic() function is built with a nice user-friendly feature that causes an unfortunate issue here. If the password argument is left blank, it will prompt the user to enter a password through a popup window. When this happens, the password cannot be left blank. Therefore, I find it easiest to just pass the API key to both arguments. The My Market News API does not seem to care, so this works fine.\n\nLet’s try that again. httr2 provides the httr2::req_auth_basic() function to facilitate basic authentication. We can supply it with our API key:\n\n\nreq &lt;- \"https://marsapi.ams.usda.gov/services/v1.2/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\"1039\") %&gt;%\n  httr2::req_auth_basic(username = Sys.getenv(\"MMN_API_KEY\"),\n                        password = Sys.getenv(\"MMN_API_KEY\"))"
  },
  {
    "objectID": "index.html#using-my-market-news-api-with-authentication-1",
    "href": "index.html#using-my-market-news-api-with-authentication-1",
    "title": "Working with APIs in R",
    "section": "Using My Market News API with Authentication",
    "text": "Using My Market News API with Authentication\nLet’s try that again. httr2 provides the httr2::req_auth_basic() function to facilitate basic authentication. We can supply it with our API key:\n\nreq &lt;- \"https://marsapi.ams.usda.gov/services/v1.2/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\"1039\") %&gt;%\n  httr2::req_auth_basic(username = Sys.getenv(\"MMN_API_KEY\"),\n                        password = Sys.getenv(\"MMN_API_KEY\"))\n\nreq\n\n&lt;httr2_request&gt;\nGET https://marsapi.ams.usda.gov/services/v1.2/reports/1039\nHeaders:\n* Authorization: &lt;REDACTED&gt;\nBody: empty\n\n\nExamining the request object, we can see the Authorization header is set, but automatically redacted by httr2 for security."
  },
  {
    "objectID": "index.html#using-my-market-news-api-with-authentication-2",
    "href": "index.html#using-my-market-news-api-with-authentication-2",
    "title": "Working with APIs in R",
    "section": "Using My Market News API with Authentication",
    "text": "Using My Market News API with Authentication\n\nThe 200 OK status code tells us the request went through successfully. I won’t go through the process of extracting the data again as it is the same as with the Datamart API.\n\nLet’s try that again. httr2 provides the httr2::req_auth_basic() function to facilitate basic authentication. We can supply it with our API key:\n\nreq &lt;- \"https://marsapi.ams.usda.gov/services/v1.2/reports\" %&gt;%\n  httr2::request() %&gt;%\n  httr2::req_url_path_append(\"1039\") %&gt;%\n  httr2::req_auth_basic(username = Sys.getenv(\"MMN_API_KEY\"),\n                        password = Sys.getenv(\"MMN_API_KEY\"))\n\nreq %&gt;%\n  httr2::req_perform()\n\n&lt;httr2_response&gt;\nGET https://marsapi.ams.usda.gov/services/v1.2/reports/1039\nStatus: 200 OK\nContent-Type: application/json\nBody: In memory (1105122 bytes)\n\n\nWe have a successful response!\n\nExtracting data from the response is the same as with the Datamart API."
  },
  {
    "objectID": "index.html#another-note-on-authentication",
    "href": "index.html#another-note-on-authentication",
    "title": "Working with APIs in R",
    "section": "Another Note on Authentication",
    "text": "Another Note on Authentication\n\nIt is worth mentioning that there are several types of API authentication you may run into.\nAdmittedly, I do not know a lot of details about how these work beyond basic authentication. However, httr2 has functionality to address these forms of authentication if you run into them.\n\nAPIs can handle authentication in a number of different ways:\n\nThe simplest, but also least secure, method is to supply the API key as a query parameter. This can be done using httr2::req_url_query().\nBasic authentication: Uses an HTTP header to provide credentials, which may include a username and/or password. This is the form we used with the My Market News API.\nJSON Web Token (JWT): A user is supplied with a digitally-signed token when they initially log into an application. The token is then required in each subsequent request.\nOAuth: A framework that uses a third party to authenticate a user. For example, when you are prompted to log into a website using a Google account.\n\n\nhttr2 has functions to support authentication using any of these forms."
  },
  {
    "objectID": "index.html#summarizing-what-we-learned",
    "href": "index.html#summarizing-what-we-learned",
    "title": "Working with APIs in R",
    "section": "Summarizing What We Learned",
    "text": "Summarizing What We Learned\n\nWeb APIs allow authorized users to access data through a structured request-response framework.\nhttr2 is a package that provides a framework for building and executing HTTP requests.\nCreate a httr2 request by passing a base URL to httr2::request().\n\nBuild on that request using httr2::req_url_path_append() and httr2::req_url_query().\nSet the authorization header using httr2::req_auth_basic() (or similar functions).\n\nExecute a httr2 request by passing it to httr2::req_perform().\nExtract JSON data using httr2::resp_body_json(simplifyVector = TRUE) (or a similar function for different data types).\nUse purrr::pluck() to drill down to lower levels of nested lists.\nBuild a function once you know how an API works!"
  },
  {
    "objectID": "index.html#for-more-information",
    "href": "index.html#for-more-information",
    "title": "Working with APIs in R",
    "section": "For More Information",
    "text": "For More Information\nUseful Sources:\n\nhttr2 documentation and the Wrapping APIs vignette\n\nOther Software:\n\nPostman: A purpose-built tool for accessing, developing, and testing APIs. Can provide a good workspace for figuring out different API options and settings. Available in Software Center.\nExcel: Feels somewhat basic, but Excel does have good tools for pulling in data from APIs. The data can then be processed using the Power Query Editor. Can be useful when working with colleagues who are not well-versed in R or Python."
  },
  {
    "objectID": "index.html#r-packages-for-apis",
    "href": "index.html#r-packages-for-apis",
    "title": "Working with APIs in R",
    "section": "R Packages for APIs",
    "text": "R Packages for APIs\nAlready existing R packages wrapping useful APIs:\n\nrnassqs: Accesses the NASS Quick Stats API (developed by Nicholas Potter of ERS)\nfredr: Accesses the Federal Reserve Economic Data (FRED) API.\ncensusapi: Accesses the Census API, making more than 1,500 endpoints available.\ntigris: Download Census Bureau TIGER/Line shapefiles.\ntidycensus: Combines access to the Census API and TIGER/Line shapefiles to simultaneously pull Census data and geometries (at the cost of a more limited set of API endpoints)."
  }
]